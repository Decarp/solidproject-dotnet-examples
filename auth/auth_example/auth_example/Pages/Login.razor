@page "/login"
@using System.Diagnostics
@using IdentityModel
@using IdentityModel.Client
@using IdentityModel.OidcClient
@using System.Web;
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using System.Net
@using System.Text
@using System.Net.Http.Headers
@using Microsoft.AspNetCore.WebUtilities
@using Microsoft.IdentityModel.Tokens
@using Newtonsoft.Json
@using System.Security.Cryptography
@using System.IdentityModel.Tokens.Jwt
@using System.Security.Claims
@using Org.BouncyCastle.Crypto
@using Org.BouncyCastle.Crypto.Generators
@using Org.BouncyCastle.Security
@inject NavigationManager navigation
@inject ProtectedLocalStorage BrowserStorage

<h3>Login</h3>

<button class="btn btn-primary" @onclick="LoginToSolid">Login To Solid Community Server</button>

@code {

    // FYI:
    // for information about the overall open-id flow in Solid, see
    // https://solid.github.io/solid-oidc/
    // https://solid.github.io/solid-oidc/primer/
    // also a useful reference:
    // https://referbruv.com/blog/posts/implementing-authorization-code-grant-using-identityserver4-with-pkce


    // the address of the Community Server
    static string identityProvider = "http://localhost:3000";

    // an identifier of our app
    static string clientName = "BlazorExample";

    // the scope of our request
    static string scope = "openid offline_access webid";

    // this is the auth or app code returned to us by the IdP
    // after the user logs in
    string appCode = string.Empty;


    static bool HasGeneratedKeys = false;
    RSAParameters PublicKey;
    RSAParameters PrivateKey;

    private async Task LoginToSolid()
    {
        // first, register ourself to the Identity Provider (IdP)
        // in this case, the Community Server
        // we're doing this because our app is not leveraging a Client Id Document, see:
        // https://solid.github.io/solid-oidc/#clientids-document
        // and section 5 overall on that page
        // if we had this, we wouldn't need to leverage dynamic client registration (see section 5.2 in the above page)

        // if you're using https://solid.github.io/solid-oidc/primer/#authorization-code-pkce-flow we are on Step 6
        // see the note " If the app doesn’t have a URI, you can either register
        // an app using static registration via some UI on the OP or use dynamic registration."
        await RegisterAppWithDynamicClientRegistration();

        // now determine the login url
        var url = await GetLoginUrl();

        // and send the user to it
        navigation.NavigateTo(url);

        // after the user logs in, the IdP (the Solid Community Server)
        // will redirect the user back to this page
        // with an app code in the Query String that we should parse out
        // this is handled by OnInitialized(), OnAfterRenderAsync(), and HandleLocationChanged()

        // after that happens we need to generate a DPoP key pair
        // in order to request a token from the IdP
        // (Steps 12, 13, and 14 on this page https://solid.github.io/solid-oidc/primer/#authorization-code-pkce-flow)
    }

    private async Task RegisterAppWithDynamicClientRegistration()
    {
        // for information on Dynamic Client Registration, see
        // https://openid.net/specs/openid-connect-registration-1_0.html

        // this value is derived from examining the result at
        // https://<identityprovider>/.well-known/openid-configuration (you can navigate to this in your browser)
        // anyone who is implementing OpenId will have this
        string url = identityProvider + "/idp/reg";

        // build a manual request via an HTTP post
        // the content of our http request will be a json object with the needed values

        // for more information see
        // https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata
        // and https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationRequest
        var client = new HttpClient();
        client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

        /*
        What we are sending:
            application type: the type of application that we are
            redirect uris: the addresses the identity provider will send the user back to after login
            client name: the name of our app
        */

        string content = @"
    {
       ""application_type"": ""web"",
       ""redirect_uris"":
       [""https://localhost:7030/login""],
       ""client_name"": ""BlazorExample"",
       ""code_challenge_method"": ""S256"",
       ""code_challenge"": ""foobar""
    }
    ";

        string codeVerifier = string.Empty;
        codeVerifier = await GetCodeVerifierFromStorage();
        if (string.IsNullOrEmpty(codeVerifier))
        {
            codeVerifier = GenerateCodeVerifier();
            await SaveCodeVerifierToStorage(codeVerifier);
        }

        Console.WriteLine($"CodeVerifier: {codeVerifier}");

        content = content.Replace("foobar", codeVerifier);

        var stringContent = new StringContent(content, Encoding.UTF8, "application/json");
        var result = await client.PostAsync(url, stringContent);

        // get the data back as a string of json,
        // deseralize it to an object that we understand,
        // and save the client id + secret for logging in
        var data = await result.Content.ReadAsStringAsync();
        var item = JsonConvert.DeserializeObject<RegisterData>(data);

        // save the values returned to us to local browser storage
        if (item is not null)
        {
            await SaveClientIdToStorage(item.client_id);
            await SaveSecretToStorage(item.client_secret);
        }
    }

    private async Task RegisterApp()
    {
        // this method does not work
        // for some reason using DynamicClientRegistrationDocument seems to make
        // the identity provider think we are not sending all the fields needed
        // when we should be able to simply omit fields that are optional
        var client = new HttpClient();
        var doc = new DynamicClientRegistrationDocument();
        doc.RedirectUris = new string[1] { navigation.BaseUri };

        var request = new DynamicClientRegistrationRequest();
        request.Address = identityProvider + "/idp/reg";
        request.Document = doc;
        request.Method = HttpMethod.Post;

        var response = await client.RegisterClientAsync(request);

        if (response.IsError) throw new Exception(response.Error);

        Debug.WriteLine(response.Json);
        Console.WriteLine(response.Json);

        var clientId = response.ClientId;
        var secret = response.ClientSecret;

        await SaveClientIdToStorage(clientId);
        await SaveSecretToStorage(secret);
    }

    private async Task<string> GetLoginUrl()
    {
        // we need to get to the login page of the identity provider
        // and give it our app information that we obtained from dynamic registration
        // this is usually http://<identityprovider>/idp/auth
        // and in the case of the community server, can be found by inspecting
        // https://<identityprovider>/.well-known/openid-configuration

        var clientId = await GetClientIdFromStorage();

        Debug.WriteLine(clientId);
        Console.WriteLine(clientId);

        string redirect = navigation.BaseUri + "login";

        // https://identitymodel.readthedocs.io/en/latest/native/manual.html?highlight=OidcClientOptions
        var options = new OidcClientOptions
            {
                // who is authenticating us, in this case, the community server
                Authority = identityProvider,

                // our client id from earlier when we identfied our app (registered via dynamic registration)
                ClientId = clientId,

                // once we've logged in, tell the identity server where to send the user back to (in this case, our app)
                RedirectUri = redirect,

                // the scope
                Scope = scope
            };

        var client = new OidcClient(options);
        var state = await client.PrepareLoginAsync();

        string url = state.StartUrl;

        await SaveCodeVerifierToStorage(state.CodeVerifier);

        url += "&prompt=consent&response_mode=query";

        Debug.WriteLine(url);
        Console.WriteLine(url);

        return url;
    }


    /// <summary>
    /// Saves the specified client id to browser storage
    /// </summary>
    /// <param name="clientId"></param>
    /// <returns></returns>
    private async Task SaveClientIdToStorage(string clientId)
    {
        await BrowserStorage.SetAsync("clientId", clientId);
    }

    /// <summary>
    /// Saves the specified secret to browser storage
    /// </summary>
    /// <param name="secret"></param>
    /// <returns></returns>
    private async Task SaveSecretToStorage(string secret)
    {
        await BrowserStorage.SetAsync("secret", secret);
    }

    private async Task<string?> GetSecretFromStorage()
    {
        string? item;

        var result = await BrowserStorage.GetAsync<string>("secret");
        item = result.Success ? result.Value : "";
        return item;
    }

    /// <summary>
    /// Returns the client id from storage, or if not set, empty string
    /// </summary>
    /// <returns></returns>
    private async Task<string?> GetClientIdFromStorage()
    {
        string? clientId;

        var result = await BrowserStorage.GetAsync<string>("clientId");
        clientId = result.Success ? result.Value : "";
        return clientId;
    }

    protected async override void OnInitialized()
    {
        // we want to check the query string values
        // if this is a re-direct back from the IdP
        // and has our auth/app code

        // this step happens after the user has clicked "Login To Solid Server"
        // and after actually logging into the server
        // it's sent the user back to us with our unique app code
        // that we use to identify ourselves
        GetQueryStringValues();
        navigation.LocationChanged += HandleLocationChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (!string.IsNullOrEmpty(appCode))
            {
                // if we have an auth/app code parsed from a query string
                // that was sent from the IdP, save it to storage
                Console.WriteLine("Save AppCode: " + appCode);
                Debug.WriteLine("Save AppCode: " + appCode);
                await SaveAppCodeToStorage(appCode);
                await GetToken();
            }

            StateHasChanged();
        }
    }

    void HandleLocationChanged(object sender, LocationChangedEventArgs e)
    {
        GetQueryStringValues();
        StateHasChanged();
    }

    void GetQueryStringValues()
    {
        // try to parse the app or auth code given to us
        // by the IdP after the user has logged in
        navigation.TryGetQueryString<string>("code", out appCode);

        if (!string.IsNullOrEmpty(appCode))
        {
            Console.WriteLine("AppCode: " + appCode);
            Debug.WriteLine("AppCode: " + appCode);
        }
    }

    public void Dispose()
    {
        navigation.LocationChanged -= HandleLocationChanged;
    }

    private async Task SaveAppCodeToStorage(string appCode)
    {
        await BrowserStorage.SetAsync("appCode", appCode);
    }

    private string GenerateCodeVerifier()
    {
        return CryptoRandom.CreateUniqueId(32);
    }

    private async Task SaveCodeVerifierToStorage(string codeVerifier)
    {
        await BrowserStorage.SetAsync("codeVerifier", codeVerifier);
    }

    private string GenerateCodeChallenge(string codeVerifier)
    {
        using (var sha256 = SHA256.Create())
        {
            var challengeBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(codeVerifier));
            return Base64Url.Encode(challengeBytes);
        }
    }

    private async Task<string?> GetCodeVerifierFromStorage()
    {
        string? codeVerifier;

        var result = await BrowserStorage.GetAsync<string>("codeVerifier");
        codeVerifier = result.Success ? result.Value : "";
        return codeVerifier;
    }

    private async Task GetToken()
    {
        string codeVerifier = string.Empty;
        codeVerifier = await GetCodeVerifierFromStorage();
        if (string.IsNullOrEmpty(codeVerifier))
        {
            codeVerifier = GenerateCodeVerifier();
            await SaveCodeVerifierToStorage(codeVerifier);
        }

        string url = identityProvider + "/idp/token";
        string clientId = await GetClientIdFromStorage();
        string clientSecret = await GetSecretFromStorage();

        string jwtToken = BuildJWTToken();

        // for sanity sake, validate this token we're about to send over the wire
        // this step isn't needed, it's just for sanity sake
        var tokenHandler = new JwtSecurityTokenHandler();

        var validationParameters = new TokenValidationParameters
            {
                // Clock skew compensates for server time drift.
                // We recommend 5 minutes or less:
                ClockSkew = TimeSpan.FromMinutes(5),

                // Specify the key used to sign the token:
                IssuerSigningKey = GetKeyAsRsa(PrivateKey),

                RequireSignedTokens = true,

                // Ensure the token hasn't expired:
                RequireExpirationTime = true,

                ValidateLifetime = true,

                // Ensure the token audience matches our audience value (default true):
                ValidateAudience = true,

                ValidAudience = navigation.BaseUri + "login",

                // Ensure the token was issued by a trusted authorization server (default true):
                ValidateIssuer = true,

                ValidIssuer = navigation.BaseUri + "login"
            };

        SecurityToken token;
        tokenHandler.ValidateToken(jwtToken, validationParameters, out token);

        if (tokenHandler.CanReadToken(jwtToken))
        {
            Console.WriteLine("Get Token: Token Is Valid");
        }

        Console.WriteLine($"Get Token: Address {url}");
        Console.WriteLine($"Get Token: ClientId {clientId}");
        Console.WriteLine($"Get Token: Secret {clientSecret}");
        Console.WriteLine($"Get Token: AppCode {appCode}");
        Console.WriteLine($"Get Token: CodeVerifier {codeVerifier}");
        Console.WriteLine($"Get Token: JWTToken {jwtToken}");

        var client = new HttpClient();
        client.DefaultRequestHeaders.Clear();

        // per https://solid.github.io/solid-oidc/primer/#authorization-code-pkce-flow
        // send the token in the header
        client.DefaultRequestHeaders.Add("DPoP", jwtToken);

        Console.WriteLine("Get Token: Request started...");

        var response = await client.RequestAuthorizationCodeTokenAsync(new AuthorizationCodeTokenRequest
            {
                Address = identityProvider + "/idp/token",

                ClientId = clientId,
                ClientSecret = clientSecret,

                Code = appCode,
                RedirectUri = navigation.BaseUri + "login",

                // optional PKCE parameter
                CodeVerifier = codeVerifier,

                GrantType = "authorization_code",

                ClientCredentialStyle = ClientCredentialStyle.PostBody
            });

        Console.WriteLine("Token Response:" + response.HttpStatusCode.ToString());

        if (response.HttpStatusCode == HttpStatusCode.OK)
        {
            // we should save the token off
            throw new NotImplementedException("Need to save token");
        }
        else
        {
            throw new Exception(response.ErrorDescription);
        }
    }

    private string BuildJWTToken()
    {
        if (!HasGeneratedKeys)
        {
            GenerateKeys();
        }

        // stolen from the internet to compute iat, exp values
        var utc0 = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
        var issueTime = DateTime.UtcNow;

        var iat = (int)issueTime.Subtract(utc0).TotalSeconds;
        var exp = (int)issueTime.AddMinutes(55).Subtract(utc0).TotalSeconds;

        // a secret key that we know
        var key = new RsaSecurityKey(PrivateKey);

        // how this token is generated
        var creds = new SigningCredentials(key, SecurityAlgorithms.RsaSha256);

        // who issued the key, in this case, ourselves
        var issuer = navigation.BaseUri + "login";

        // who this for, in this case, ourselves
        var audience = navigation.BaseUri + "login";

        // how long is this token good for
        var jwtValidity = DateTime.Now.AddDays(1);

        // identify the type of crypto for our keys
        var algMap = new Dictionary<string, string>();
        algMap.Add("alg", "RS256");

        var simpleToken = new JwtSecurityToken(issuer,
          audience,
          expires: jwtValidity,
          signingCredentials: creds);

        // https://solid.github.io/solid-oidc/primer/#authorization-code-pkce-flow
        // per the above, we need to send as "dpop+jwt"
        var header = new JwtHeader(creds, algMap, "dpop+jwt");

        var jwk = GetPublicJsonWebKey();

        header.Add("jwk", jwk);

        var payload = new JwtPayload(simpleToken.Claims);

        // we want to only use this token at the Community Solid server
        payload.AddClaim(new Claim("htu", identityProvider + "/idp/token"));

        // only on post methods
        payload.AddClaim(new Claim("htm", "POST"));

        // unique identifier for the token
        payload.AddClaim(new Claim("jti", Guid.NewGuid().ToString()));

        // we rebuild the token with all the additional headers, claims, etc.
        var dpopToken = new JwtSecurityToken(header, payload, header.ToString(), payload.ToString(), simpleToken.RawSignature);

        // the date when the token was issued, must be an integer
        dpopToken.Payload.AddClaim(new Claim("iat", iat.ToString(), ClaimValueTypes.Integer));

        // debugging
        var text = new JwtSecurityTokenHandler().WriteToken(dpopToken);
        return text;
    }

    /// <summary>
    /// Pulls the public key from as a JsonWebKey, if available. If not, it will generate it.
    /// </summary>
    /// <returns>The Public Key in JsonWebKey format</returns>
    private JsonWebKey GetPublicJsonWebKey()
    {
        if (!HasGeneratedKeys)
        {
            GenerateKeys();
        }

        var key = new RsaSecurityKey(PublicKey);
        return JsonWebKeyConverter.ConvertFromRSASecurityKey(key);
    }

    /// <summary>
    /// Pulls the private key from as a JsonWebKey, if available. If not, it will generate it.
    /// </summary>
    /// <returns>The Private Key in JsonWebKey format</returns>
    private JsonWebKey GetPrivateJsonWebKey()
    {
        if (!HasGeneratedKeys)
        {
            GenerateKeys();
        }

        var key = new RsaSecurityKey(PrivateKey);
        return JsonWebKeyConverter.ConvertFromRSASecurityKey(key);
    }

    /// <summary>
    /// Generates asymetric keys (RSA) and sets the Public/Private keys for this page.
    /// </summary>
    private void GenerateKeys()
    {
        var rsa = RSA.Create();

        PublicKey = rsa.ExportParameters(false);
        PrivateKey = rsa.ExportParameters(true);

        HasGeneratedKeys = true;
    }

    /// <summary>
    /// Returns the RSA key as an RSA Security Key. Used in generating a JsonWebKey.
    /// </summary>
    /// <param name="parameter">RSAParameter (usually a generated RSA public/private key)</param>
    /// <returns>The key as an RSA Security Key</returns>
    private RsaSecurityKey GetKeyAsRsa(RSAParameters parameter)
    {
        return new RsaSecurityKey(parameter);
    }

}
