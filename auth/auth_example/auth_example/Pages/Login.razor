@page "/login"
@using System.Diagnostics
@using IdentityModel.Client
@using IdentityModel.OidcClient
@using System.Web;
@using Microsoft.AspNetCore.Components.Server.ProtectedBrowserStorage
@using System.Net
@using System.Text
@using System.Net.Http.Headers
@using Newtonsoft.Json
@inject NavigationManager navigation
@inject ProtectedLocalStorage BrowserStorage

<h3>Login</h3>

<button class="btn btn-primary" @onclick="LoginToSolid">Login To Solid Community Server</button>

@code {

    // FYI:
    // for information about the overall open-id flow in Solid, see
    // https://solid.github.io/solid-oidc/
    // https://solid.github.io/solid-oidc/primer/
    // also a useful reference:
    // https://referbruv.com/blog/posts/implementing-authorization-code-grant-using-identityserver4-with-pkce


    // the address of the Community Server
    static string identityProvider = "http://localhost:3000";

    // an identifier of our app
    static string clientName = "BlazorExample";

    // the scope of our request
    static string scope = "openid offline_access webid";

    // this is the auth or app code returned to us by the IdP
    // after the user logs in
    string appCode = string.Empty;

    private async Task LoginToSolid()
    {
        // first, register ourself to the Identity Provider (IdP)
        // in this case, the Community Server
        // we're doing this because our app is not leveraging a Client Id Document, see:
        // https://solid.github.io/solid-oidc/#clientids-document
        // and section 5 overall on that page
        // if we had this, we wouldn't need to leverage dynamic client registration (see section 5.2 in the above page)

        // if you're using https://solid.github.io/solid-oidc/primer/#authorization-code-pkce-flow we are on Step 6
        // see the note " If the app doesn’t have a URI, you can either register 
        // an app using static registration via some UI on the OP or use dynamic registration."
        await RegisterAppWithDynamicClientRegistration();

        // now determine the login url
        var url = await GetLoginUrl();

        // and send the user to it
        navigation.NavigateTo(url);

        // after the user logs in, the IdP (the Solid Community Server)
        // will redirect the user back to this page
        // with an app code in the Query String that we should parse out
        // this is handled by OnInitialized(), OnAfterRenderAsync(), and HandleLocationChanged()

        // after that happens we need to generate a DPoP key pair
        // in order to request a token from the IdP
        // (Steps 12, 13, and 14 on this page https://solid.github.io/solid-oidc/primer/#authorization-code-pkce-flow)
    }

    private async Task RegisterAppWithDynamicClientRegistration()
    {
        // for information on Dynamic Client Registration, see
        // https://openid.net/specs/openid-connect-registration-1_0.html

        // this value is derived from examining the result at
        // https://<identityprovider>/.well-known/openid-configuration (you can navigate to this in your browser)
        // anyone who is implementing OpenId will have this
        string url = identityProvider + "/idp/reg";

        // build a manual request via an HTTP post
        // the content of our http request will be a json object with the needed values

        // for more information see
        // https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata
        // and https://openid.net/specs/openid-connect-registration-1_0.html#RegistrationRequest
        var client = new HttpClient();
        client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

        /*
        What we are sending:
            application type: the type of application that we are
            redirect uris: the addresses the identity provider will send the user back to after login
            client name: the name of our app
        */

        string content = @"
        {
           ""application_type"": ""web"",
           ""redirect_uris"":
           [""https://localhost:7030/login""],
           ""client_name"": ""BlazorExample""
        }
        ";
        var stringContent = new StringContent(content, Encoding.UTF8, "application/json");
        var result = await client.PostAsync(url, stringContent);

        // get the data back as a string of json,
        // deseralize it to an object that we understand,
        // and save the client id + secret for logging in
        var data = await result.Content.ReadAsStringAsync();
        var item = JsonConvert.DeserializeObject<RegisterData>(data);

        // save the values returned to us to local browser storage
        if (item is not null)
        {
            await SaveClientIdToStorage(item.client_id);
            await SaveSecretToStorage(item.client_secret);
        }
    }

    private async Task RegisterApp()
    {
        // this method does not work
        // for some reason using DynamicClientRegistrationDocument seems to make
        // the identity provider think we are not sending all the fields needed
        // when we should be able to simply omit fields that are optional
        var client = new HttpClient();
        var doc = new DynamicClientRegistrationDocument();
        doc.RedirectUris = new string[1] { navigation.BaseUri };

        var request = new DynamicClientRegistrationRequest();
        request.Address = identityProvider + "/idp/reg";
        request.Document = doc;
        request.Method = HttpMethod.Post;

        var response = await client.RegisterClientAsync(request);

        if (response.IsError) throw new Exception(response.Error);

        Debug.WriteLine(response.Json);
        Console.WriteLine(response.Json);

        var clientId = response.ClientId;
        var secret = response.ClientSecret;

        await SaveClientIdToStorage(clientId);
        await SaveSecretToStorage(secret);
    }

    private async Task<string> GetLoginUrl()
    {
        // we need to get to the login page of the identity provider
        // and give it our app information that we obtained from dynamic registration
        // this is usually http://<identityprovider>/idp/auth
        // and in the case of the community server, can be found by inspecting
        // https://<identityprovider>/.well-known/openid-configuration

        var clientId = await GetClientIdFromStorage();

        Debug.WriteLine(clientId);
        Console.WriteLine(clientId);

        string redirect = navigation.BaseUri + "login";

        // https://identitymodel.readthedocs.io/en/latest/native/manual.html?highlight=OidcClientOptions
        var options = new OidcClientOptions
            {
                // who is authenticating us, in this case, the community server
                Authority = identityProvider,

                // our client id from earlier when we identfied our app (registered via dynamic registration)
                ClientId = clientId,

                // once we've logged in, tell the identity server where to send the user back to (in this case, our app)
                RedirectUri = redirect,

                // the scope
                Scope = scope
            };

        var client = new OidcClient(options);
        var state = await client.PrepareLoginAsync();

        string url = state.StartUrl;

        url += "&prompt=consent&response_mode=query";

        Debug.WriteLine(url);
        Console.WriteLine(url);

        return url;
    }


    /// <summary>
    /// Saves the specified client id to browser storage
    /// </summary>
    /// <param name="clientId"></param>
    /// <returns></returns>
    private async Task SaveClientIdToStorage(string clientId)
    {
        await BrowserStorage.SetAsync("clientId", clientId);
    }

    /// <summary>
    /// Saves the specified secret to browser storage
    /// </summary>
    /// <param name="secret"></param>
    /// <returns></returns>
    private async Task SaveSecretToStorage(string secret)
    {
        await BrowserStorage.SetAsync("secret", secret);
    }

    /// <summary>
    /// Returns the client id from storage, or if not set, empty string
    /// </summary>
    /// <returns></returns>
    private async Task<string?> GetClientIdFromStorage()
    {
        string? clientId;

        var result = await BrowserStorage.GetAsync<string>("clientId");
        clientId = result.Success ? result.Value : "";
        return clientId;
    }

    protected async override void OnInitialized()
    {
        // we want to check the query string values
        // if this is a re-direct back from the IdP
        // and has our auth/app code

        // this step happens after the user has clicked "Login To Solid Server"
        // and after actually logging into the server
        // it's sent the user back to us with our unique app code
        // that we use to identify ourselves
        GetQueryStringValues();
        navigation.LocationChanged += HandleLocationChanged;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (!string.IsNullOrEmpty(appCode))
            {
                // if we have an auth/app code parsed from a query string
                // that was sent from the IdP, save it to storage
                Console.WriteLine("Save AppCode: " + appCode);
                Debug.WriteLine("Save AppCode: " + appCode);
                await SaveAppCodeToStorage(appCode);
            }

            StateHasChanged();
        }
    }

    void HandleLocationChanged(object sender, LocationChangedEventArgs e)
    {
        GetQueryStringValues();
        StateHasChanged();
    }

    void GetQueryStringValues()
    {
        // try to parse the app or auth code given to us
        // by the IdP after the user has logged in
        navigation.TryGetQueryString<string>("code", out appCode);

        if (!string.IsNullOrEmpty(appCode))
        {
            Console.WriteLine("AppCode: " + appCode);
            Debug.WriteLine("AppCode: " + appCode);
        }
    }

    public void Dispose()
    {
        navigation.LocationChanged -= HandleLocationChanged;
    }

    private async Task SaveAppCodeToStorage(string appCode)
    {
        await BrowserStorage.SetAsync("appCode", appCode);
    }

}
